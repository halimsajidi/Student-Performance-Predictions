# -*- coding: utf-8 -*-
"""Notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vHxlTScz4MBzmF6Jb2R1GevNzvmzj_Ra

# Submission Akhir: Students' Performance

- Nama: Halim Sajidi
- Email: halimsajidi14@gmail.com
- Id Dicoding: halimsajidi

## Persiapan

### Menyiapkan library yang dibutuhkan
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split

#model machine learning
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from xgboost import XGBClassifier

# evaluasi model
from sklearn.metrics import confusion_matrix, recall_score, f1_score, accuracy_score, precision_score

# deploy
from joblib import dump, load

"""### Menyiapkan data yang akan digunankan"""

df = pd.read_csv('data.csv')
df

"""Dataset perlu dipisahkan sesuai dengan kolomnya"""

df.head(1).values

"""Dengan menggunakan argumen sep=';' untuk mengindikasikan bahwa data dipisahkan dengan titik koma."""

# Membaca file CSV dengan pemisah titik koma
df = pd.read_csv('data.csv', sep=';')

df

df.columns

"""## Data Understanding

### Deskripsi Variabel
"""

df.info()

"""Dataset yang digunakan adalah tentang performa murid dengan jumlah data sebanyak 4424 baris dan 37 kolom yang terbagi menjadi 36 kolom independen yang akan digunakan untuk melatih model dan 1 kolom yaitu kolom Status sebagai targetnya."""

df.describe()

df.columns

"""**Kolom kategorik**"""

df_cat = df.select_dtypes(include="object")
cat_col = df_cat.columns
df_cat.head(5)

"""**Kolom Numerik**"""

df_num = df.select_dtypes(include=["int64", "float64"])
num_col = df_num.columns
df_num.head()

"""### Menangani Missing Value"""

df.isnull().sum()

"""Dapat dilihat pada dataset ini tidak terdapat missing value sama sekali jadi untuk tahap ini bisa di skip dan langsung ke tahap berikutnya.

### Menangani Outliers
"""

plt.figure(figsize=(20, 12))

# Calculate the number of rows and columns needed for the subplots
num_rows = 7
num_cols = 6

for i, column in enumerate(num_col, 1):
    plt.subplot(num_rows, num_cols, i)
    sns.boxplot(data=df, x=df[column])
    plt.tight_layout()

"""Berdasarkan visualisasi di atas, terlihat adanya outlier pada beberapa kolom. Namun, mengetahui keberadaan outlier tidak serta-merta berarti outlier tersebut harus dihapus atau diganti. Setiap data pada kolom tersebut dianggap masuk akal dan sesuai dengan konteksnya, sehingga tidak perlu dilakukan perubahan terhadap outlier tersebut.

Tetapi khusus untuk kolom Curricular_units_1st_sem_grade dan Curricular_units_2nd_sem_grade diperlukan visualsasi lebih lanjut
"""

# Visualisasi Status berdasarkan usia
sns.boxplot(x='Status', y='Curricular_units_1st_sem_grade', data=df_new)
plt.title('Curricular_units_1st_sem_grade vs Status')
plt.show()

# Visualisasi Status berdasarkan usia
sns.boxplot(x='Status', y='Curricular_units_2nd_sem_grade', data=df_new)
plt.title('Curricular_units_2nd_sem_grade vs Status')
plt.show()

"""Dapat dilihat terdapat nilai 0 pada graduate, hal ini tidak masuk akal seharusnya rata-rata nilai siswa yang berstatus graduate tidak boleh 0, sehingga nilai 0 ini dianggap sebagai outlier dan harus dihapus."""

# Mengisi nilai 0 pada kolom 'Curricular_units_1st_sem_grade' dan 'Curricular_units_2nd_sem_grade' dengan rata-rata
df['Curricular_units_1st_sem_grade'].replace(0, np.nan, inplace=True)
df['Curricular_units_2nd_sem_grade'].replace(0, np.nan, inplace=True)

df['Curricular_units_1st_sem_grade'].fillna(df['Curricular_units_1st_sem_grade'].mean(), inplace=True)
df['Curricular_units_2nd_sem_grade'].fillna(df['Curricular_units_2nd_sem_grade'].mean(), inplace=True)

"""## Data Visualisation

### Distribusi Status
"""

df_new = df.copy()

status_cnt = df['Status'].value_counts()

# Plotting the pie chart
plt.figure(figsize=(10, 7))
plt.pie(status_cnt, labels=status_cnt.index, autopct='%1.1f%%', startangle=140)
plt.title('Distribusi Status Murid')
plt.axis('equal')
plt.show()

"""Berdasarkan plot pie chart di atas menunjukkan bahwa proporsi murid graduate sebesar 49.9% dengan jumlah murid yang dropout cukup banyak yaitu 32.1%

### Hubungan status siswa dengan Jenis Kelamin
"""

# Visualisasi distribusi gender
sns.countplot(x='Gender', data=df)
plt.title('Distribusi gender murid')
plt.xticks(ticks=[0, 1], labels=['Female', 'Male'])
plt.show()

"""Jumlah siswa laki-laki lebih sedikit dibandingkan dengan siswa perempuan"""

# Menghitung jumlah Status berdasarkan Gender
Status_Gender_counts = df.groupby(['Gender', 'Status']).size().unstack(fill_value=0)

# Membuat figure untuk pie charts
fig, ax = plt.subplots(1, 2, figsize=(12, 6))

# Pie chart untuk Male
ax[0].pie(Status_Gender_counts.loc[1],
           labels=Status_Gender_counts.columns,
           autopct='%1.1f%%',
           startangle=90,
           colors=['#66c2a5', '#fc8d62', '#8da0cb'])
ax[0].axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
ax[0].set_title('Persentase Status Siswa Laki-laki')

# Pie chart untuk Female
ax[1].pie(Status_Gender_counts.loc[0],
           labels=Status_Gender_counts.columns,
           autopct='%1.1f%%',
           startangle=90,
           colors=['#66c2a5', '#fc8d62', '#8da0cb'])
ax[1].axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
ax[1].set_title('Persentase Status Siswa Perempuan')

# Menampilkan pie charts
plt.tight_layout()
plt.show()

"""Berdasarkan plot di atas siswa laki-laki memiliki persen dropout lebih tinggi (45.1%) dibandingkan dengan perempuan (25.1%). Lalu untuk tingkat gradutenya siswa laki-laki memiliki tingkat kelulusan yang rendah (35.2%) di bandingkan perempuan (57.9%).

### Marital status dan Status siswa
"""

Marital_status_mapping = {
    1: 'single',
    2: 'married',
    3: 'widower',
    4: 'divorced',
    5: 'facto union',
    6: 'legally separated',
}

# Ganti angka dengan nama Marital_status
df_new['Marital_status'] = df['Marital_status'].replace(Marital_status_mapping)

# Visualisasi Status vs Marital_status
plt.figure(figsize=(15,6))
sns.countplot(x='Marital_status', hue='Status', data=df_new)
plt.title('Marital status vs Status siswa')
plt.xticks(rotation=0)
plt.show()

"""Dapat dilihat bahwa kebanyakan siswa masih status single dan beberapa lainnya sudah menikah atau cerai. Selain itu, siswa yang sudah menikah atau cerai lebih banyak yang dropout dibandingkan graduate.

### Status berdasarkan Usia (Age)
"""

# Visualisasi Status berdasarkan usia
sns.boxplot(x='Status', y='Age_at_enrollment', data=df)
plt.title('Hubungan Usia pada Saat Pendaftaran dengan status Siswa')
plt.show()

"""Dapat dilihat siswa yang berumur antara 20 sampai 30 tahun pada saat pendaftaran cenderung dropout, dibandingkan dengan siswa yang berumur dibawah 25 tahun.

### Status vs Course

value pada kolom course masih dalam bentuk numerik sehingga dipelukan pengubahan sesuai dengan nama mata kuliahnya
"""

course_mapping = {
    33: 'Biofuel Production Technologies',
    171: 'Animation and Multimedia Design',
    8014: 'Social Service (evening attendance)',
    9003: 'Agronomy',
    9070: 'Communication Design',
    9085: 'Veterinary Nursing',
    9119: 'Informatics Engineering',
    9130: 'Equinculture',
    9147: 'Management',
    9238: 'Social Service',
    9254: 'Tourism',
    9500: 'Nursing',
    9556: 'Oral Hygiene',
    9670: 'Advertising and Marketing Management',
    9773: 'Journalism and Communication',
    9853: 'Basic Education',
    9991: 'Management (evening attendance)'
}

# Ganti angka dengan nama course
df_new['Course'] = df['Course'].replace(course_mapping)

# Visualisasi Status vs Course
plt.figure(figsize=(15,6))
sns.countplot(x='Course', hue='Status', data=df_new)
plt.title('Pengaruh Course terhadap Status')
plt.xticks(rotation=90)
plt.show()

# 1. Top 5 Course Graduate Tertinggi
top_graduate = df_new[df_new['Status'] == 'Graduate'].groupby('Course').size().reset_index(name='Count')
top_graduate = top_graduate.sort_values(by='Count', ascending=False).head(5)

# 2. Top 5 Course Dropout Tertinggi
top_dropout = df_new[df_new['Status'] == 'Dropout'].groupby('Course').size().reset_index(name='Count')
top_dropout = top_dropout.sort_values(by='Count', ascending=False).head(5)

# 3. Top 5 Course Enrolled Tertinggi
top_Enrolled = df_new[df_new['Status'] == 'Enrolled'].groupby('Course').size().reset_index(name='Count')
top_Enrolled = top_Enrolled.sort_values(by='Count', ascending=False).head(5)

# Tampilkan hasil
print("Top 10 Course dengan Graduate Tertinggi:")
top_graduate

print("Top 10 Course dengan Dropout Tertinggi:")
top_dropout

print("Top 10 Course dengan Enrolled Tertinggi:")
top_Enrolled

"""Status siswa juga dipengaruhi oleh course yang dijalani, dapat dilihat persebaran data pada grafik diatas sangat beragam, course nursing sendiri memiliki status graduate tertinggi, lalu Management (evening attendance)	dan management memiliki tingkat dropout yang tinggi. Dengan demikian, status siswa dapat dipengaruhi dengan course apa yang dipilih.

### Beasiswa dan Status
"""

plt.figure(figsize=(8,6))
sns.countplot(x='Scholarship_holder', hue='Status', data=df)
plt.title('Hubungan Penerima Beasiswa dengan Status Mahasiswa')
plt.xticks(ticks=[0, 1], labels=['No', 'Yes'])
plt.ylabel('Jumlah Mahasiswa')
plt.show()

"""Berdasarkan grafik dia atas, Penerima beasiswa cenderung berstatus graduate dan tidak dropout dibandingkan dengan siswa yang tidak menerima beasiswa.

### The number of curricular units dan Status
"""

sns.boxplot(x='Status', y='Curricular_units_1st_sem_enrolled', data=df)
plt.title('Hubungan Jumlah unit kurikuler dengan status Siswa pada semester 1')
plt.show()

sns.boxplot(x='Status', y='Curricular_units_2nd_sem_enrolled', data=df)
plt.title('Hubungan Jumlah unit kurikuler dengan status Siswa pada semester 2')
plt.show()

"""Dapat dilihat siswa yang mengambil curricular units lebih banyak cenderung berstatus graduate dibandingkan yang tidak. Terutama siswa yang mengambil lebih dari 20 unit."""

sns.boxplot(x='Status', y='Curricular_units_1st_sem_grade', data=df_new)
plt.title('Hubungan rata-rata nilai pada semester 1 dengan status Siswa')
plt.show()

sns.boxplot(x='Status', y='Curricular_units_2nd_sem_grade', data=df_new)
plt.title('Hubungan rata-rata nilai pada semester 2 dengan status Siswa')
plt.show()

"""Dua grafik di atas menggambarkan bahwa siswa yang mendapat rata-rata grade atau nilai yang tinggi, cenderung berstatus graduate.

## Data Preparation / Preprocessing

### Encoding

Pada tahap ini dilakukan encoding menggunakan label encoder, bertujuan agar data dapat diproses pada saat pengembangan model machine learning.
"""

le = LabelEncoder()

for column in cat_col:
    df[column] = le.fit_transform(df[column])

df

"""### splitting data

Pembagian data dilakukan agar mendapatkan dataset train dan juga test dengan proporsi 80% dan 20%
"""

X = df.drop(columns=['Status'])
y = df['Status']

X.head(5).to_csv('test.csv', index=False)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print('X_train', X_train.shape)  #Printing the X_train Features Shape
print('y_train', y_train.shape)  #Printing the y_train Labels Shape
print('X_test', X_test.shape)    #Printing the X_test Features Shape
print('y_test', y_test.shape)    #Printing the y_test Labels  Shape

"""## Modeling

Tahap ini dilakukan pengembangan model machine learning dengan tujuan untuk memprediksi karyawan yang tetap tinggal di perusahaan atau melakukan resign.

Setiap baseline model yang dikembangkan, diberikan random_state. random_state digunakan sebagai pengontrol pengacakan yang diterapkan pada data sebelum melakukan pemisahan.

### Logistic Regression

**Keunggulan:**
- Sederhana dan mudah diinterpretasikan
- Kecepatan dan efisiensi
- Multicollinearity Handling: Dapat menangani multicollinearity menggunakan regularization (L1 atau L2).

**Kekurangan:**
- Kinerja terbatas pada masalah kompleks
- Kurang efektif untuk outlier
"""

# melakukan training model
lr = LogisticRegression(random_state=24)
lr.fit(X_train, y_train)

# Predicting the X_test
pred = lr.predict(X_test)

# Testing the model accuracy with different parameters
acc = accuracy_score(y_test, pred)  # Getting the Accuracy Score
f1 = f1_score(y_test, pred, average='macro')  # Getting the F1 Score for multiclass
rec = recall_score(y_test, pred, average='macro')  # Getting the Recall Score for multiclass
prec = precision_score(y_test, pred, average='macro')  # Getting the Precision Score for multiclass
cm_lr = confusion_matrix(y_test, pred)  # Getting the confusion Matrix

# Defining a DataFrame
results = pd.DataFrame([['LogisticRegression', acc, f1, rec, prec]],
                           columns=['Model', 'Accuracy_Score', 'F1_Score', 'Recall_Score', 'Precision_Score'])

# Printing the Model Results with different Metrics
results

"""### Random Forest

**Keunggulan:**
- Dapat menangani data non-linear: Random Forest dapat menangani hubungan kompleks antar fitur tanpa perlu membuat asumsi linearitas.
-Overfitting Resistance: Dengan menggabungkan banyak decision tree, Random Forest cenderung tidak overfitting.
- Fitur penting: Random Forest menyediakan cara untuk mengevaluasi fitur mana yang paling berpengaruh melalui feature importance.

**Kekurangan:**
- Waktu komputasi: Lebih lambat untuk dilatih dibandingkan model yang lebih sederhana, terutama pada dataset yang besar.
- Kurang interpretasi: Meskipun memberikan hasil yang baik, interpretasi model ini sulit dibandingkan model linear.
"""

rf = RandomForestClassifier(random_state=42)
rf.fit(X_train, y_train)

# Membuat prediksi pada X_test
pred = rf.predict(X_test)

# Menghitung metrik evaluasi
acc = accuracy_score(y_test, pred)  # Menghitung Accuracy
f1 = f1_score(y_test, pred, average='macro')  # Menghitung F1 Score (multiclass)
rec = recall_score(y_test, pred, average='macro')  # Menghitung Recall (multiclass)
prec = precision_score(y_test, pred, average='macro')  # Menghitung Precision (multiclass)
cm_rf = confusion_matrix(y_test, pred)  # Menghitung Confusion Matrix

# Menyimpan hasil evaluasi dalam DataFrame
model_results = pd.DataFrame([['Random Forest', acc, f1, rec, prec]],
                             columns=['Model', 'Accuracy_Score', 'F1_Score', 'Recall_Score', 'Precision_Score'])

# Menggabungkan hasil evaluasi ke dalam DataFrame `results`
results = pd.concat([results, model_results], ignore_index=True)

# Menampilkan hasil
results

"""###  Support Vector Machine (SVM)

**Keunggulan:**
- Kinerja tinggi pada data kecil: SVM sering bekerja dengan sangat baik untuk dataset dengan ukuran kecil hingga menengah.
- Mengatasi masalah non-linear: Kernel trick memungkinkan SVM untuk mengatasi masalah klasifikasi non-linear.
- Overfitting minimal: Karena SVM memaksimalkan margin antara kelas, model ini cenderung menghindari overfitting, terutama pada data dengan high dimensionality.

**Kekurangan:**
- Lambat pada dataset besar: Waktu komputasi dan kebutuhan memori meningkat pesat seiring dengan ukuran dataset.
- Pemilihan kernel: Memilih kernel yang tepat (linear, polynomial, RBF, dsb.) bisa menjadi tantangan dan memerlukan banyak eksperimen.
"""

svm = SVC(random_state=42)
svm.fit(X_train, y_train)

# Making predictions on X_test
pred = svm.predict(X_test)

# Calculating evaluation metrics
acc = accuracy_score(y_test, pred)  # Calculating Accuracy
f1 = f1_score(y_test, pred, average='macro')  # Calculating F1 Score (multiclass)
rec = recall_score(y_test, pred, average='macro')  # Calculating Recall (multiclass)
prec = precision_score(y_test, pred, average='macro')  # Calculating Precision (multiclass)
cm_svm = confusion_matrix(y_test, pred)  # Calculating Confusion Matrix

# Storing evaluation results in a DataFrame
model_results = pd.DataFrame([['SVM', acc, f1, rec, prec]],
                             columns=['Model', 'Accuracy_Score', 'F1_Score', 'Recall_Score', 'Precision_Score'])

# Combining evaluation results into the `results` DataFrame
results = pd.concat([results, model_results], ignore_index=True)

# Displaying the results
results

"""### XGBoost

**Keunggulan:**
- Kinerja tinggi: Sangat efektif dalam menghasilkan hasil yang baik pada data yang kompleks. Model ini sering kali menghasilkan akurasi lebih tinggi dibandingkan metode lain.
- Flexibilitas: Mendukung banyak fungsi loss dan dapat digunakan untuk masalah klasifikasi, regresi, dan ranking.
- Regularisasi: Gradient boosting (seperti XGBoost) memiliki mekanisme regularisasi bawaan yang membantu mencegah overfitting.

**Kekurangan:**
- Waktu pelatihan: Membutuhkan waktu pelatihan yang lebih lama, terutama pada dataset yang besar.
- Overfitting: Jika tidak dikontrol dengan baik, model ini bisa rentan terhadap overfitting, terutama pada data kecil.
"""

xgb = XGBClassifier(random_state=42)
xgb.fit(X_train, y_train)

# Membuat prediksi pada X_test
pred = xgb.predict(X_test)

# Menghitung metrik evaluasi
acc = accuracy_score(y_test, pred)  # Menghitung Accuracy
f1 = f1_score(y_test, pred, average='macro')  # Menghitung F1 Score (multiclass)
rec = recall_score(y_test, pred, average='macro')  # Menghitung Recall (multiclass)
prec = precision_score(y_test, pred, average='macro')  # Menghitung Precision (multiclass)
cm_xgb = confusion_matrix(y_test, pred)  # Menghitung Confusion Matrix

# Menyimpan hasil evaluasi dalam DataFrame
model_results = pd.DataFrame([['XGBoost', acc, f1, rec, prec]],
                             columns=['Model', 'Accuracy_Score', 'F1_Score', 'Recall_Score', 'Precision_Score'])

# Menggabungkan hasil evaluasi ke dalam DataFrame `results`
results = pd.concat([results, model_results], ignore_index=True)

# Menampilkan hasil
results

"""## Evaluation

Metrik yang digunakan untuk mengevaluasi model adalah Akurasi, Precision, Recall, dan F1-Score. Metrik ini dipilih karena sesuai dengan kebutuhan yaitu klasifikasi.
"""

results

"""Dapat dilihat setelah dilakukan pengembangan model machine learning, didapatkan model terbaik yaitu XGBoost dengan akurasi 76.9%

## Deployment

Model yang sudah dibuat selanjutnya adalah menyimpanan yang mana tahap ini dilakukan, agar model yang sudah dibuat bisa digunakan kembali.
"""

# Menyimpan model ke file
dump(rf, 'XGBoost_model.joblib')

"""## menyimpan dataset dan requirement"""

df_new.to_csv('dataset_for_dashboard.csv', index=False)

pip freeze > requirements.txt

